# List1



## 알고리즘

- 의사코드(슈도코드)와 순서도
  - **노트에다가 정리하는 연습 필요!!**

```python
# 슈도코드

CalcSum( n )
    sum <- 0
    for i : 1 -> n
        sum <- sum + i
    return sum;
```

- APS 과정의 목표 중의 하나는 **‘보다 좋은 알고리즘을 이해하고 활용하는 것’**이다.
  - 코드에 정답은 없다
  - 각자에게 있어서 좋은 알고리즘은 다를 수 있다
  - 무조건 짧은 코드, 빠른 코드가 좋은 코드가 아니다
  - 코드가 조금 길더라도 이해하기 좋은 것이 좋은 코드
  - 짧은 코드에 집중하지 않기

## 배열

- 저장하는 형태. 묶음으로 저장하는 방식.
  
  - 파이썬에서는 list를 통해 배열을 구현

- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
  
  - 문법적으로 자료형을 구분하지는 않지만, 사실은 파이썬이 다 하고 있는 것. 정수, 소수 저장하는 방식이 다름.
  - 내부적으로 자료형이 있음

- 배열의 필요성
  
  - 하나의 선언을 통해 둘 이상의 변수 선언 가능
  - 다수의 변수로는 하기 힘든 작업을 배열을 활요해 쉽게 가능

- 1차원 배열의 선언
  
  - `Arr = []`
  - `Arr = [0] * 10` 칸이 있는 배열 선언. 크기를 정해놓는 것.

- 연습 문제 : Gravity
  
  ```python
  N = int(input())
  arr = list(map(int, input().split())
  
  # 1. 가장 큰 수를 찾을 수 있는가? (내장함수 사용x)
  
  maxV = arr[0] # 첫 원소를 최대값으로 가정
  for i in range(1, N): # 나머지 모든 원소에 대해
          if arr[i] > maxV:
                  maxV = arr[i]
  ```
  
  - 배열의 인덱스 연산을 잘하는 것이 IM의 목표
  - 각 원소에 대해 오른쪽에 있는 원소 중 더 작은 원소의 개수 구하기

## 정렬

- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값, 혹은 그 반대의 순서대로 재배열하는 것
- 키 : 자료를 정렬하는 기준이 되는 특정 값
- 정렬 방식의 종류
  - `버블 정렬`
  - `카운팅 정렬`
  - `선택 정렬`
  - `퀵 정렬`
    - **코드로 구현할 수 있을 정도로 연습을 해야 함**
    - **손으로 그려볼 것!!!**
  - 삽입 정렬
  - 병합 정렬

### 버블 정렬

- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- 가장 간단한 방식의 정렬에 해당
- 정렬 과정
  - 첫 번째 원소부터 인접한 원소까지 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다
  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다
  - 교환하며 자리를 이동하는 모습이 물 위로 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다.
- 시간 복잡도 = O(n^2)
- 버블 정렬 코드로 구현 (오름차순)

```python
def BubbleSort(arr, n):
        for i in range(n-1, 0, -1):
                for j in range(0, i):
                        if arr[j] > arr[j+1]:
                                arr[j], arr[j+1] = arr[j+1], arr[j]
```

```c
# 슈도 코드
BubbleSort(arr, n)
        for i : n-1 -> 1 # 구간의 끝을 정함
                for j : 0 -> i-1 # 인접한 원소 중 왼쪽 인덱스
                        if arr[j] > arr[j+1]:
                                arr[j], arr[j+1] = arr[j+1], arr[j]
```

### 카운팅 정렬

- 카운팅 정렬이 좀 어렵다면 아래 순서로 공부
  - 버블 → 선택 → 카운팅
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
- 제한 사항
  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능 : 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다
  - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다
- 시간 복잡도 = O(n + k)
- [0, 4, 1, 3, 1, 2, 4, 1] 을 카운팅 정렬하는 과정

```python
def Counting_sort(A, B, k)
# A [] -- 입력 배열(1 to k)
# B [] -- 정렬된 배열
# C [] -- 카운트 배열

        C = [0] * (k+1)

        for i in range(0, len(A)):
                C[A[i]] += 1

        for i in range(1, len(C)):
                C[i] += C[i-1]

        for i in range(len(B)-1, -1, -1):
                C[A[i]] -= 1
                B[C[A[i]]] = A[i]
```

## 완전 검색

- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다
- 생각보다 까다로울 수 있음 (순열, 조합, 부분집합 → 이건 A형 가서…)

### 순열

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 완전 검색 방법 중 하나는 모든 숫자 배열을 다 늘어놓는 것
- 서로 다른 n개 중 r개를 택하는 순열 : `nPr`
- IM에서는 안씀
- {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수

```python
for i1 in range(1, 4):
        for i2 in range(1, 4):
                if i2 != i1:
                        for i3 in range(1, 4):
                                if i3 != i1 and i3 != i2:
                                        print(i1, i2, i3)
```

## 탐욕(Greedy) 알고리즘

- 최적해를 구하는 데 사용되는 근시안적인 방법
- 실행 과정 (Ex. 거스름돈 줄이기)
  - 해 선택
  - 실행 가능성 검사
  - 해 검사
- Baby-gin 그리디로 구현
